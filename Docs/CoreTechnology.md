# 核心技术与算法

## 一、系统架构

### 1.1 技术栈
- **前端**：HTML5 + CSS3 + JavaScript（原生）
- **后端**：Node.js + Express
- **核心算法**：C语言
- **数据格式**：二进制DAT文件（GBK编码）
- **编码转换**：iconv-lite（GBK → UTF-8）

### 1.2 架构设计
```
用户浏览器
    ↓ HTTP请求
Node.js服务器（Express）
    ↓ 调用C程序
C程序（main.exe）
    ↓ 读取数据
bus_data.dat（二进制数据文件）
```

---

## 二、核心算法

### 2.1 Dijkstra最短路径算法

本项目使用**Dijkstra算法**求解最优公交路线。

**算法特点**：
- 时间复杂度：O(V²)（V为节点数）
- 适用于非负权重图
- 保证找到最优解

**实现方式**：
```c
void dijkstra_double(adj *g, int s, double *dist, int *pre) {
    // 1. 初始化距离数组
    // 2. 循环V次，每次找最小距离未访问节点
    // 3. 更新相邻节点距离
    // 4. 标记节点为已访问
}
```

### 2.2 状态扩展图（State-Expanded Graph）

为了处理换乘问题，本项目使用**状态扩展图**技术。

**核心思想**：
- 每个站点在每条线路上都有一个独立的状态节点
- 状态节点 = 站点ID × 线路数 + 线路ID
- 同一站点不同线路之间的边表示换乘

**图结构**：
```
节点总数 = 站点数 × 线路数 + 1（超级源点）

边的类型：
1. 同线路相邻站点：权重 = 行驶时间
2. 同站点不同线路：权重 = 换乘时间
3. 超级源点到起点：权重 = 0或首次乘车费用
```

**示例**：
```
假设有3个站点（A、B、C）和2条线路（L1、L2）

状态节点：
- A_L1 (0), A_L2 (1)
- B_L1 (2), B_L2 (3)
- C_L1 (4), C_L2 (5)
- 超级源点 (6)

边：
- A_L1 → B_L1：L1线路上A到B的时间
- A_L1 → A_L2：在A站从L1换乘到L2的时间
```

---

## 三、时间计算模型

### 3.1 速度设置

```c
普通线路：500 m/min = 30 km/h
BRT快速公交：600 m/min = 36 km/h
夜班线路：450 m/min = 27 km/h
特殊线路（85路）：700 m/min = 42 km/h
```

**说明**：这是纯行驶速度，不含停靠时间。

### 3.2 站点间时间计算

```c
// 1. 计算直线距离（欧几里得距离）
dist = sqrt((x2-x1)² + (y2-y1)²)

// 2. 应用道路曲折系数
dist = dist × 1.2

// 3. 计算行驶时间（秒）
time = (dist / speed) × 60

// 4. 加上停靠时间
time = time + 30秒
```

**参数说明**：
- 道路曲折系数：1.2（实际道路比直线长20%）
- 停靠时间：30秒/站（上下客时间）

### 3.3 换乘时间

| 模式 | 换乘时间计算 |
|------|-------------|
| 模式1（最便宜） | 不计时间，只计费用 |
| 模式2（最快-不等车） | 固定5分钟（300秒） |
| 模式3（最快-等车） | 5分钟 + 平均等车时间（发车间隔/2） |

### 3.4 总时间公式

```
总时间 = Σ(站点间时间) + Σ(换乘时间)

其中：
站点间时间 = (直线距离 × 1.2 / 速度) × 60 + 30秒
换乘时间 = 根据模式确定
```

---

## 四、坐标系统

### 4.1 经纬度转平面坐标

数据源使用真实的GPS经纬度，需要转换为平面米坐标用于距离计算。

**转换公式**：
```c
// 参考原点：常州北站（lat0, lon0）
ky = 111000.0;  // 纬度1度 ≈ 111km
kx = 111000.0 × cos(lat0 × π / 180.0);  // 经度1度（考虑纬度影响）

// 转换
x = (lon - lon0) × kx;  // 米
y = (lat - lat0) × ky;  // 米
```

**说明**：
- 地球纬度1度约等于111公里
- 经度1度的实际距离随纬度变化（赤道最长，两极为0）
- 常州位于北纬31.8度左右

### 4.2 距离计算

使用欧几里得距离公式：
```c
double euclid_dist(station *s1, station *s2) {
    double dx = s1->x - s2->x;
    double dy = s1->y - s2->y;
    return sqrt(dx * dx + dy * dy);
}
```

---

## 五、数据结构

### 5.1 站点结构
```c
typedef struct {
    char name[64];    // 站点名称
    double x;         // X坐标（米）
    double y;         // Y坐标（米）
} station;
```

### 5.2 线路结构
```c
typedef struct {
    char code[16];      // 线路编号
    double price;       // 票价（元）
    double interval;    // 发车间隔（分钟）
    double speed;       // 速度（米/分钟）
    int *stops;         // 站点ID数组
    int stop_cnt;       // 站点数量
} line;
```

### 5.3 图结构
```c
typedef struct arcnode {
    int to;              // 目标节点
    double w;            // 边权重（时间或费用）
    int line_idx;        // 所属线路
    struct arcnode *next;
} arcnode;

typedef struct {
    int n;               // 节点数
    int m;               // 边数
    arcnode **head;      // 邻接表头指针数组
} adj;
```

---

## 六、优化策略

### 6.1 三种优化模式

| 模式 | 优化目标 | 边权重设置 |
|------|---------|-----------|
| 模式1 | 最便宜 | 费用（元） |
| 模式2 | 最快（不等车） | 时间（秒） |
| 模式3 | 最快（等车） | 时间+等车（秒） |

### 6.2 权重设置策略

**模式1（最便宜）**：
```c
同线路边：权重 = 0
换乘边：权重 = 下一条线路票价
```

**模式2（最快-不等车）**：
```c
同线路边：权重 = 行驶时间 + 停靠时间
换乘边：权重 = 300秒（5分钟步行）
```

**模式3（最快-等车）**：
```c
同线路边：权重 = 行驶时间 + 停靠时间
换乘边：权重 = 300秒 + 发车间隔/2
```

---

## 七、数据文件格式

### 7.1 源文件（bus_source.txt）

文本格式，包含线路和站点信息：
```
LINE: 线路号,起点站,终点站,总站数
STOP: 序号,站点名称,纬度,经度
```

### 7.2 数据文件（bus_data.dat）

二进制格式，结构如下：
```
[站点数量: int]
[站点1: name(64字节) + x(double) + y(double)]
[站点2: ...]
...
[线路数量: int]
[线路1: code(16字节) + price + interval + speed + stop_cnt + stops数组]
[线路2: ...]
...
```

### 7.3 数据生成流程

```
bus_source.txt
    ↓ (build_data.c)
bus_data.dat
    ↓ (main.c)
路线规划结果（JSON）
```

---

## 八、API接口

### 8.1 路线规划
```
POST /api/route
Content-Type: application/json

请求：
{
  "start": "常工院",
  "end": "常州北站",
  "mode": 2
}

响应：
{
  "success": true,
  "start": "常工院",
  "end": "常州北站",
  "transfers": 1,
  "totalTime": 24.5,
  "timeUnit": "分钟",
  "segments": [...]
}
```

### 8.2 站点搜索
```
GET /api/search-stations?keyword=常州

响应：
{
  "success": true,
  "stations": ["常州北站", "常州站", ...]
}
```

---

## 九、性能分析

### 9.1 时间复杂度

- **Dijkstra算法**：O(V²)
- **图构建**：O(V × L²)（V=站点数，L=线路数）
- **路径恢复**：O(V)

### 9.2 空间复杂度

- **状态节点数**：V × L + 1
- **边数**：约 O(V × L²)
- **内存占用**：约 (V × L) × sizeof(arcnode)

### 9.3 实际数据规模

- 站点数：385个
- 线路数：14条
- 状态节点：385 × 14 + 1 = 5391个
- 查询时间：< 100ms

---

## 十、可扩展性

### 10.1 添加新线路

1. 编辑 `backend/c/output/bus_source.txt`
2. 添加线路和站点信息
3. 运行 `build_data.exe` 重新生成数据
4. 重启服务

### 10.2 调整参数

**速度调整**（build_data.c）：
```c
double line_speed(char *code) {
    return 500.0;  // 修改这里
}
```

**时间参数调整**（main.c）：
```c
dist = dist * 1.2;  // 道路曲折系数
w = w + 30.0;       // 停靠时间（秒）
w = 300.0;          // 换乘时间（秒）
```

### 10.3 支持其他城市

只需修改 `bus_source.txt`：
- 更新站点经纬度
- 更新线路信息
- 重新生成数据文件

---

## 十一、技术亮点

1. **状态扩展图**：巧妙处理换乘问题
2. **多目标优化**：支持费用、时间等多种优化目标
3. **真实坐标**：基于GPS经纬度的精确距离计算
4. **高性能**：C语言核心算法，毫秒级响应
5. **跨平台**：Web界面，任何设备可访问
6. **模块化设计**：前后端分离，易于维护扩展

---

## 参考资料

- Dijkstra算法：《算法导论》第24章
- 状态扩展图：公交路线规划经典方法
- 经纬度转换：WGS84坐标系统
